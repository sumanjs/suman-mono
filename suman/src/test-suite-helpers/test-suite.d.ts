import { ITestBlock, TestSuiteMethods } from 'suman-types/dts/test-suite';
import { ITestDataObj } from 'suman-types/dts/it';
import { IBeforeObj } from 'suman-types/dts/before';
import { IBeforeEachObj } from 'suman-types/dts/before-each';
import { IAfterObj } from 'suman-types/dts/after';
import { IAFterEachObj } from 'suman-types/dts/after-each';
import { makeStartSuite } from './make-start-suite';
import { VamootProxy } from 'vamoot';
import { ISuman } from "../suman";
import { EVCb } from 'suman-types/dts/general';
export interface ISumanSymbols {
    [key: string]: symbol;
}
export declare const TestBlockSymbols: ISumanSymbols;
export interface IInjectedValues {
    [key: string]: any;
}
export declare type TestSuiteGetterFn<T> = () => Array<T>;
export interface TestBlockOpts {
    parallel: boolean;
    mode: 'series' | 'serial' | 'parallel';
    fixed: boolean;
    skip: boolean;
    only: boolean;
    series: boolean;
    serial: boolean;
}
export interface ITestBlockOpts {
    isTopLevel?: boolean;
    desc: string;
    title?: string;
    opts: TestBlockOpts;
    suman: ISuman;
    gracefulExit: any;
    handleBeforesAndAfters: any;
    notifyParent: any;
}
export declare class TestBlock implements ITestBlock {
    alreadyHandledAfterAllParentHooks: boolean;
    isDelayed: boolean;
    limit: number;
    supply: object;
    opts: TestBlockOpts;
    testId: number;
    isRootSuite?: boolean;
    childCompletionCount: number;
    allChildBlocksCompleted: boolean;
    isSetupComplete: boolean;
    parallel: boolean;
    skipped: boolean;
    fixed: boolean;
    only: boolean;
    filename: string;
    shared: VamootProxy;
    skippedDueToOnly: boolean;
    completedChildrenMap: Map<TestBlock, boolean>;
    private __suiteSuman;
    desc: string;
    title: string;
    _run?: (val: any, cb: EVCb<any>) => void;
    __resume: (val: any) => void;
    bIsFirstArg: boolean;
    __supply: object;
    __startSuite: ReturnType<typeof makeStartSuite>;
    ioc: IInjectedValues;
    skippedDueToDescribeOnly?: boolean;
    interface: string;
    injectedValues: IInjectedValues;
    parent: TestBlock;
    getTestsParallel: Array<any>;
    getLoopTests: Array<any>;
    getResumeValue?: Function;
    fatal?: Function;
    testBlockMethodCache: Object;
    constructor(obj: ITestBlockOpts);
    getInjections(): IInjectedValues;
    getChildren(): Array<TestBlock>;
    getTests(): Array<ITestDataObj>;
    getParallelTests(): Array<ITestDataObj>;
    getBefores(): Array<IBeforeObj>;
    getBeforeBlocks(): Array<IBeforeObj>;
    getBeforesFirst(): Array<IBeforeObj>;
    getBeforesLast(): Array<IBeforeObj>;
    getBeforeEaches(): Array<IBeforeEachObj>;
    getAftersFirst(): Array<IAfterObj>;
    getAftersLast(): Array<IAfterObj>;
    getAfters(): Array<IAfterObj>;
    getAfterBlocks(): Array<any>;
    getAfterEaches(): Array<IAFterEachObj>;
    getAfterAllParentHooks(): any;
    getAfterBlockList(): Array<IAfterObj>;
    getBeforeBlockList(): any[];
    resume(): void;
    toString(): string;
    invokeChildren(val: any, start: EVCb<any>): void;
    bindExtras(): this;
    private mergeBefores;
    private mergeAfters;
    getHooks(): TestSuiteMethods;
    set(k: any, v: any): boolean;
    get(k?: any): any;
    getValues(mandatory: string, ...args: Array<string>): Array<any>;
    getMap(...args: Array<string>): object;
    getInjectedValue(key: string): any;
    getInjectedValues(...args: string[]): Array<any>;
    getInjectedMap(...args: string[]): object;
    getSourced(): any;
    getSourcedValue(v: string): any;
    getSourcedValues(...args: string[]): Array<any>;
    getSourcedMap(...args: string[]): object;
}
